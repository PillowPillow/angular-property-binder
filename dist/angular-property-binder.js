// angular-property-binder
// version: 0.1.12
// author: Gaignoux Nicolas
// generated: Thu Apr 16 2015 19:20:53 GMT+0200 (Paris, Madrid (heure d’été))
// Autogenerated, do not edit. All changes will be undone.
(function (window,document,angular) {

	" use strict; ";
	angular.module('PropertyBinder', []);
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	angular.module('PropertyBinder').provider('PropertyBinder.providers.binder', function () {
		this.$get = function () {
			var Binder = (function () {
				function Binder() {
					var properties = arguments[0] === undefined ? [] : arguments[0];
	
					_classCallCheck(this, Binder);
	
					this._properties = properties instanceof Array ? properties : [properties];
					this._binded = false;
					this._sealed = false;
					this._to = undefined;
					this._from = undefined;
					this._path = [];
					this._aliases = {};
					this._change = function () {};
				}
	
				_createClass(Binder, [{
					key: 'from',
					value: function from(scope) {
						var path = arguments[1] === undefined ? [] : arguments[1];
	
						this._throwErrorIfAlreadyBinded();
						this._path = typeof path === 'string' ? path = path.split('.') : path;
						this._from = scope;
						return this;
					}
				}, {
					key: 'to',
					value: function to(scope) {
						this._throwErrorIfAlreadyBinded();
	
						this._to = scope;
						return this;
					}
				}, {
					key: 'as',
					value: function as() {
						var aliases = arguments[0] === undefined ? {} : arguments[0];
	
						this._throwErrorIfAlreadyBinded();
	
						if (aliases instanceof Object) {
	
							if (aliases instanceof Array) {
								for (var i = 0; i < aliases.length; i++) {
									if (!!this._properties[i]) this._aliases[this._properties[i]] = aliases[i];
								}
							} else this._aliases = aliases;
						} else {
	
							if (typeof aliases === 'string') {
								if (this._properties.length === 1) {
									var alias = aliases;
									this._aliases = {};
									this._aliases[this._properties[0]] = alias;
								} else throw Error('Ambiguous aliases');
							}
						}
	
						return this;
					}
				}, {
					key: 'onchange',
					value: function onchange() {
						var changeEvent = arguments[0] === undefined ? function () {} : arguments[0];
	
						this._change = changeEvent;
						return this;
					}
				}, {
					key: 'seal',
					value: function seal() {
						this._sealed = true;
						return this;
					}
				}, {
					key: 'unseal',
					value: function unseal() {
						this._sealed = false;
						return this;
					}
				}, {
					key: 'toggleSealing',
					value: function toggleSealing() {
						this._sealed = !this._sealed;
						return this;
					}
				}, {
					key: 'apply',
					value: function apply() {
	
						this._throwErrorIfAlreadyBinded();
						if (this._from && this._to && this._properties.length > 0) for (var i = 0; i < this._properties.length; i++) this._createProperty(this._properties[i]);
	
						this._binded = true;
						return this;
					}
				}, {
					key: 'destroy',
					value: function destroy() {
	
						for (var i = 0; i < this._properties.length; i++) this._deleteProperty(this._properties[i]);
	
						this._binded = false;
						return this;
					}
				}, {
					key: '_deleteProperty',
					value: function _deleteProperty(property) {
						var alias = this._aliases[property] || property;
						delete this._to[alias];
					}
				}, {
					key: '_createProperty',
					value: function _createProperty(property) {
						var _this = this;
	
						Object.defineProperty(this._to, this._aliases[property] || property, {
							enumerable: true,
							configurable: true,
							get: function get() {
								var src = _this._getSrc();
								return src[property] instanceof Function ? src[property].bind(src) : src[property];
							},
							set: function set(value) {
								if (!_this._sealed) {
									var src = _this._getSrc();
									var oldValue = src[property];
									src[property] = value;
									if (oldValue !== value) _this._change(value, oldValue);
								} else throw Error('Trying to update a sealed property');
							}
						});
					}
				}, {
					key: '_getSrc',
					value: function _getSrc() {
						var src = this._from;
						if (this._path.length > 0) for (var i = 0; i < this._path.length; i++) {
							src = src[this._path[i]];
							if (!src) throw Error('unable to acces to the given property');
						}
						return src;
					}
				}, {
					key: '_throwErrorIfAlreadyBinded',
					value: function _throwErrorIfAlreadyBinded() {
						if (this._binded) throw Error('Property already binded');
					}
				}]);
	
				return Binder;
			})();
	
			return Binder;
		};
	});
	var _bind = Function.prototype.bind;
	angular.module('PropertyBinder').service('PropertyBinder.services.binder', ['PropertyBinder.providers.binder', function (Binder) {
		return function () {
			for (var _len = arguments.length, parameters = Array(_len), _key = 0; _key < _len; _key++) {
				parameters[_key] = arguments[_key];
			}
	
			return new (_bind.apply(Binder, [null].concat(parameters)))();
		};
	}]);

})(window,window.document,window.angular);